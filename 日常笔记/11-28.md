###### ***缺省：***

######  缺省参数的核心是【编译期确定默认值、调用时左到右匹配】

1\. 半缺省参数必须从右往左依次来给出，不能间隔着给                                       编译器从左到右匹配，中间参数有默认值而右侧没有，编译器无法确定参数对应关系。

2\. 缺省参数不能在函数声明和定义中同时出现                                          声明是给调用者看，定义是给编译器看，混在一起，编译器不知道调用哪个

3\. 缺省值必须是常量或者全局变量                                                       变量没有确定的值，调用时不知道会有什么值或者变量改变，局部变量有生命周期

4\. C语言不支持（编译器不支持）                           缺省：                                                                                                                  缺省参数的核心是【编译期确定默认值、调用时左到右匹配】

1\. 半缺省参数必须从右往左依次来给出，不能间隔着给                                       编译器从左到右匹配，中间参数有默认值而右侧没有，编译器无法确定参数对应关系。

2\. 缺省参数不能在函数声明和定义中同时出现                                          声明是给调用者看，定义是给编译器看，混在一起，编译器不知道调用哪个

3\. 缺省值必须是常量或者全局变量                                                       变量没有确定的值，调用时不知道会有什么值或者变量改变，局部变量有生命周期

4\. C语言不支持（编译器不支持）





###### ***函数重载：？***

是函数的一种特殊情况，C++允许在同一作用域中声明几个功能类似的同名函数，这些同名函数的形参列表(参数个数 或 类型 或 类型顺序)不同，常用来处理实现功能类似数据类型不同的问题。





###### ***引用：（给人起外号一样）***

不是新定义一个变量，而是给已存在变量取了一个别名，编译器不会为引用变量开辟内存空间，它和它引用的变量共用同一块内存空间。



a. 引用在定义时必须初始化                                          给别人起外号，要找到那个人在起外号



b. 一个变量可以有多个引用                                          一个人可以有个外号



c. 引用一旦引用一个实体，再不能引用其他实体            你给人起了一个外号，你就会这么叫他，不怎么改这个外号给他



int\& Add(int a, int b)

{

 	int c = a + b;

 	return c;

}                                                                                                 -----———— ————》》》 正常理解一开始是3，通过调用函数，但是生命周期结束，空间释放，引用的是

int main()

{                                                                                                                             被释放的空间，又因为3，4压栈进来应改是7 ，但是因为不同的编译器，打印的可能不是7，是

 	int\& ret = Add(1, 2);

 	Add(3, 4);                                                                                                    空间地址，引用释放的空间时，悬空引用访问了无效内存，在某些编译器（如 VS2022）中，你

 	cout <<  "Add(1, 2) is :" << ret << endl;                                                   的代码可能打印 3；在 GCC 中可能打印 7；在开启优化后可能打印随机数 —— 这都是未定义

 	return 0;                                                                                                           行为的表现。

}



###### ***值和引用的作为返回值类型的性能比较***

以值作为参数或者返回值类型，在传参和返回期间，函数不会直接传递实参或者将变量本身直接返回，而是传递实参或者返回变量的一份临时的拷贝，因此用值作为参数或者返回值类型，效率是非常低下的，尤其是当参数或者返回值类型非常大时，效率就更低。在底层实现上实际是有空间的，因为引用是按照指针方式来实现的



5\. 在sizeof中含义不同：引用结果为引用类型的大小，但指针始终是地址空间所占字节个数(32位平台下占4个字节)



6\. 引用自加即引用的实体增加1，指针自加即指针向后偏移一个类型的大小



7\. 有多级指针，但是没有多级引用



###### ***inline：内联函数    无调用开销 + 类型安全 + 支持调试***

消除函数调用开销，频繁调用的短小函数，向编译器发送建议，减少调用函数创建栈帧开销，有的编译器不允许，函数体短小（1-5 行代码，无复杂逻辑），有时编译器拒绝，

拒绝原因：

1\. 复杂函数（含循环、switch、递归、大量局部变量，频繁调用的函数）；

2\. 少被调用的函数（如程序启动时只调用一次的初始化函数，内联无意义）；

3\. 需要取地址的函数（如函数指针、回调函数）；

4\. 虚函数（运行时多态，编译时无法确定函数体）。

5\. 避免过度内联                                                                                                        内联会导致代码体积增大（“代码膨胀”），影响cpu





###### ***auto:***

自动类型推导,让编译器自动推导变量的类型



适用范围：

范围 for 循环遍历容器（最推荐）；

复杂类型（迭代器、lambda、STL 容器嵌套类型）；

临时变量，且类型明确（比如 auto res = func();，func 返回类型清晰）；

函数返回值类型复杂，且所有返回值类型一致（C++14+



不适用范围：

类型不明确，影响代码可读性（比如 auto x = some\_func();，读者不知道 x 是什么类型）；

需要明确指定类型的场景

底层 const 敏感的场景（比如需要保留顶层 const，需显式声明 const auto）。



###### ***类的大小：***

一个类的大小，实际就是该类中”成员变量”之和，不考虑成员函数。当然也要注意内存对齐，注意空类的大小，方便取值计算（不对齐也可以，修改对齐数就好了）。空类比较特殊，编译器给了空类一个字节来唯一标识这个类的对象。

 先看是否有 虚函数：有则加 vptr 大小（4/8 字节）；

再计算 成员变量 的总大小（遵循内存对齐）；

若无成员变量（或仅有成员函数 / 静态成员）：分配 1 字节占位符；

成员函数、静态成员不影响类实例大小。

class A1 {

public:

    void f1() {} // 成员函数                                                     4

private:

    int \_a;     // 成员变量（int 占 4 字节）

};



class A2 {

public:

    void f2() {} // 仅有成员函数，无成员变量                            1

};



class A3 {}; // 空类（无成员变量，无成员函数）                   1



###### ***this指针：：？？？***





***C++程序在编译后的内存分布情况如下：***



栈区（Stack）：



存放局部变量、函数参数、函数调用信息等。

数据的分配和回收都由系统自动管理。

具有自动释放内存的特性，随着函数的结束而自动销毁。





堆区（Heap）：



存放动态分配的内存，由程序员手动分配和释放。

用于存放程序运行中动态创建的对象或数组。

需要手动释放内存，避免内存泄漏.



全局/静态存储区（Data/BSS）：



存放全局变量、静态变量及静态常量。

在程序运行期间一直存在，直到程序结束才被释放。

初始化的全局/静态变量存放在Data区，未初始化的全局/静态变量存放在BSS区。

代码区（Text）：



存放程序的可执行代码，包括函数体和常量数据。

只读区域，不允许修改。

可以多个进程共享同一段代码区





###### ***this 指针：***

1.this 是成员函数中默认存在的隐含参数，编译器自动传入，无需程序员声明；

它的类型是 类名\* const（比如 Person\* const this）：指针本身不可修改（不能给 this 赋值，比如 this = \&p2 编译报错），但可以通过 this 修改对象的成员变量（除非是 const 成员函数）



2\. 仅在成员函数中可用

this 指针只能在非静态成员函数内访问，静态成员函数（static）、全局函数、类外代码中都无法使用；

原因：静态成员函数属于 “类本身”，不依赖具体对象，调用时不会传入 this 指针。



3\. 空指针调用成员函数的风险                               ？？

如果用 nullptr（空指针）调用非静态成员函数，且函数内没有通过 this 访问成员变量，程序可能不会崩溃；但如果访问了成员变量（即间接使用 this->成员），会触发空指针解引用，程序崩溃：

Person\* p = nullptr;

p->showInfo(); // 若 showInfo 中仅打印固定字符串（不访问成员变量），可能不崩溃；

p->setInfo("Charlie", 25); // 必然崩溃：setInfo 中通过 this 访问 name/age，空指针解引用



4\. const 成员函数中，this 是 const 指针        ？？

在成员函数后加 const（const 成员函数），this 的类型会变为 const 类名\* const（比如 const Person\* const this）：

指针本身不可修改（第二个 const）；

指向的对象也不可修改（第一个 const）—— 即不能通过 this 修改成员变量：

class Person {

public:

    // const 成员函数：只能读成员变量，不能改

    void showInfo() const {

        // this->age = 30; 编译报错：const 成员函数不能修改成员变量

        cout << this->age << endl; // 只读，允许

    }

};



***this 指针的显式使用场景（什么时候需要写 this->）***

大多数情况下，this 可以省略（比如 cout << name 等价于 cout << this->name），但以下场景必须显式使用：



1\. 成员变量与函数参数同名（最常用）

当成员变量和函数参数名字相同时，必须用 this-> 区分：

void setAge(int age) {

    this->age = age; // this->age 是成员变量，右边 age 是参数

}



2.从成员函数中返回当前对象（链式调用）     ??

返回 \*this（当前对象的引用），可以实现函数链式调用（比如 p.setAge(20).setName("Alice")）：

class Person {

private:

    string name;

    int age;

public:

    // 返回 Person\&（对象引用），支持链式调用

    Person\& setAge(int age) {

        this->age = age;

        return \*this; // 返回当前对象本身

    }



    Person\& setName(string name) {

        this->name = name;

        return \*this;

    }

};



int main() {

    Person p;

    // 链式调用：连续调用成员函数

    p.setAge(20).setName("Alice").showInfo(); // 输出 Alice 20

    return 0;

}

注意：返回 Person\&（引用）而非 Person（值），避免返回时拷贝对象，提高效率。





3\. 在类的内部调用其他重载的成员函数

当类中有多个重载的成员函数时，用 this-> 明确调用当前对象的其他重载版本（避免歧义）：



4\. 区分成员变量与全局变量

若全局变量与成员变量同名，用 this-> 明确指定访问成员变量：





四、this 指针的内存分配（不占用类实例大小）

很多人会误以为 this 指针占用类实例的内存，但实际：

this 是函数参数，存储在栈上（和普通函数参数一样），而非类实例中；

类的实例大小仅由成员变量、虚函数表指针（若有）决定，this 指针不影响 sizeof(类名)





***常见误区（避坑指南）***

1\. 给 this 赋值：this 是 const 指针（类名\* const），不能修改指向，比如 this = \&p2 编译报错；



2\. 在静态成员函数中使用 this：静态成员函数不依赖对象，调用时不会传入 this，因此无法使用 this 指针；



3\. \*返回 this 而非 this：this 是指针，返回 this 会返回指针类型，而返回 \*this 是返回对象引用，链式调用需返回引用；



4\. const 成员函数修改成员变量：const 成员函数中 this 是 const 类名\* const，不能通过 this 修改成员变量，除非成员变量是 mutable（可变的）。



总结          ???

this 指针是 C++ 类的核心隐含机制，核心作用是标识当前调用成员函数的对象：

它是成员函数的隐含参数，自动传入，仅在非静态成员函数中可用；

类型默认是 类名\* const，const 成员函数中是 const 类名\* const；

显式使用场景：区分同名变量、链式调用返回对象、调用重载函数；

不占用类实例内存，不影响 sizeof(类名)。





###### ***c++编译后内存分布：***



1\. 栈区（Stack）：系统自动管理的 “临时内存”

核心特点：

分配 / 回收：编译器自动完成（函数调用时分配栈帧，函数返回时释放），无需程序员干预；

内存结构：栈是 “先进后出”（FILO）的连续内存空间，栈指针（esp 寄存器）控制栈的增长 / 收缩；

大小限制：栈的默认大小较小（Windows 约 1-8MB，Linux 约 8MB），超出会触发 栈溢出（Stack Overflow）；

存储内容：局部变量（非 static）、函数参数、函数返回地址、寄存器上下文（函数调用时保存）。



栈溢出



2\. 堆区（Heap）：程序员手动管理的 “动态内存”

核心特点：

分配 / 回收：需手动调用 new/malloc 分配，delete/free 回收（C++ 推荐用 new/delete，会调用构造 / 析构函数）；

内存结构：堆是不连续的内存空间（由操作系统的内存管理器管理），内存地址从低到高增长；

大小限制：堆的大小远大于栈（接近物理内存上限），适合存储大块数据；

存储内容：动态创建的对象、数组、自定义数据结构（如链表、树的节点）。



内存泄漏



3\. 全局 / 静态存储区（Data + BSS）：程序生命周期的 “全局内存”

核心特点：

生命周期：从程序启动到程序结束（早于 main 函数初始化，晚于 main 函数销毁）；

分区规则：

Data 区（初始化数据区）：存放已初始化的全局变量、静态变量（static）、静态常量；

BSS 区（未初始化数据区）：存放未初始化的全局变量、静态变量（程序启动时会自动初始化为 0）；

存储内容：全局变量（global）、静态变量（static，包括全局静态和局部静态）。



全局 / 静态变量地址集中在同一区域（介于堆和栈之间）

局部变量只能初始化一次



4\. 代码区（Text）：只读的 “指令内存”

核心特点：

存储内容：程序的机器指令（编译后的二进制代码）、字符串常量（const char\* str = "hello" 中的 "hello"）；

属性：只读（防止程序意外修改指令）、可共享（多个进程运行同一程序时，共享同一段代码区，节省内存）；

生命周期：从程序启动到结束，与全局 / 静态存储区同时存在。



代码区地址是最低的（远低于堆、全局 / 静态区、栈

修改字符串常量



小数据、临时变量用栈：比如局部变量、函数参数，访问速度快，无需管理内存；

大数据、长期存在的对象用堆：比如动态数组、链表节点、自定义对象（避免栈溢出）；

全局 / 静态变量慎用：生命周期长，易造成数据耦合，且多线程环境下需注意线程安全；

C++ 中优先用智能指针（unique\_ptr/shared\_ptr）管理堆内存：自动回收，避免内存泄漏；

避免在栈上分配大块数据：比如超大数组，优先用堆或 std::vector（底层是堆内存）。

总结

C++ 内存分布的核心是 “不同区域对应不同生命周期和管理方式”：

代码区：只读指令，系统管理；

全局 / 静态区：程序级生命周期，系统管理；

栈区：函数级生命周期，编译器自动管理；

堆区：自定义生命周期，程序员手动管理。





###### ***C++ 类的六个默认成员函数***：

C++ 中，空类并非真的 “空”，—— 编译器会自动生成 6 个「默认成员函数」（当用户未显式定义时）



构造函数（默认构造）

析构函数

拷贝构造函数

赋值运算符重载（operator=）

取地址运算符重载（operator\&）

const 取地址运算符重载（const operator\&）



***1.构造函数：对象的 “初始化器”   ？***

作用：

创建对象时自动调用，初始化对象的成员变量（默认版本仅做 “浅初始化”，比如内置类型不初始化，自定义类型调用其默认构造）。

核心特性：

函数名与类名相同，无返回值（连 void 都没有）；

可重载（支持多个构造函数，按参数匹配调用）；

若用户未显式定义任何构造函数，编译器才生成「默认构造函数」（无参数）；

隐含 this 指针，指向当前正在创建的对象。





***2. 析构函数：对象的 “清理工” ？***

作用：

对象生命周期结束时自动调用，释放对象占用的资源（默认版本仅做 “浅清理”，比如不释放堆内存，需手动显式定义析构函数处理资源）。

核心特性：

函数名是 ~类名，无返回值，无参数（不可重载，一个类仅有一个析构函数）；

若用户未显式定义，编译器生成「默认析构函数」；

隐含 this 指针，指向当前正在销毁的对象。





***3. 拷贝构造函数：对象的 “复制器”          ?????***

作用：

用一个已存在的对象，创建一个新的同类型对象（比如 Person p2 = p1; ），默认版本是「浅拷贝」。

核心特性：

函数名与类名相同，参数是「const 类名\& 」（必须是引用，否则会引发无限递归）；

若用户未显式定义，编译器生成「默认拷贝构造函数」；

隐含 this 指针，指向「新创建的对象」，参数指向「被拷贝的对象」。

关键：浅拷贝的坑与深拷贝的必要性

默认拷贝构造是 “浅拷贝”—— 仅复制成员变量的数值（比如指针变量复制的是地址，而非堆内存内容），可能导致「双重释放」：



解决：显式定义深拷贝构造



***4. 赋值运算符重载：对象的 “赋值器”***

作用：

两个已存在的对象之间赋值（比如 p2 = p1;），默认版本是「浅拷贝」，与拷贝构造的区别是：拷贝构造是 “创建新对象”，赋值重载是 “修改已有对象”。

核心特性：

函数名是 operator=，返回值是「类名 \&」（支持链式赋值，比如 p3 = p2 = p1;）；

参数是「const 类名 \&」（避免拷贝，提高效率）；

若用户未显式定义，编译器生成「默认赋值运算符重载」；

隐含 this 指针，指向「被赋值的对象」（左边对象），参数指向「赋值的对象」（右边对象）。



***深拷贝和浅拷贝：***



以stack为例：



Stack 类的关键成员：

\_array：指向堆内存的指针（动态分配，需手动释放）；

\_size/\_capacity：普通值类型（栈上存储，直接复制无问题）。

浅拷贝和深拷贝的差异，只针对「堆内存指针」，值类型的复制逻辑完全一致。



**1. 浅拷贝的定义**

编译器自动生成的拷贝构造 / 赋值重载，逻辑是：逐字节复制所有成员变量的「数值」—— 对于指针 \_array，复制的是「堆内存的地址」，而非「地址指向的堆内存内容」。

2\. 浅拷贝的现象（原程序崩溃的核心）

用 Stack s2(s1); 触发浅拷贝后，内存布局如下：

s1:

  \_array → 堆内存\[1,2,3,4, ?, ?, ...]（容量10）

  \_size = 4

  \_capacity = 10



s2:

  \_array → 同一个堆内存\[1,2,3,4, ?, ?, ...]（和s1共享）

  \_size = 4

  \_capacity = 10



两个对象的 \_array 指向 同一块堆内存；

堆内存的内容没有被复制，只是地址被共享。



3\. 浅拷贝的后果（原程序崩溃 + 数据污染）

（1）直接崩溃：双重释放

程序退出时，s1 和 s2 会自动调用析构函数：

先析构 s2：free(s2.\_array) → 释放共享的堆内存；

再析构 s1：free(s1.\_array) → 再次释放同一块堆内存；

C++ 中「重复释放堆内存」是未定义行为，直接触发程序崩溃（内存错误）。

（2）隐藏问题：数据污染

即使不崩溃，修改一个对象的堆内存，会影响另一个对象：



s1.Push(5); // s1 往共享堆内存添加 5，此时堆内存内容为 \[1,2,3,4,5,...]

// s2 的 \_size 还是 4，但 s2.\_array 指向的堆内存已被 s1 修改

// 后续 s2.Push(6) 会覆盖 s1 的 5，造成数据混乱



**深拷贝的定义**

程序员显式定义拷贝构造 / 赋值重载，逻辑是：

对于「值类型成员（\_size/\_capacity）」：直接复制数值；

对于「堆内存指针（\_array）」：

为新对象分配 独立的堆内存（容量和原对象一致）；

将原对象堆内存中的「内容」复制到新内存中；

新对象的 \_array 指向新分配的堆内存，而非原对象的地址。

2\. 深拷贝的现象（解决崩溃的核心）

用显式深拷贝的拷贝构造函数创建 s2 后，内存布局如下：

s1:

  \_array → 堆内存A\[1,2,3,4, ?, ?, ...]（独立堆内存）

  \_size = 4

  \_capacity = 10



s2:

  \_array → 堆内存B\[1,2,3,4, ?, ?, ...]（新分配的独立堆内存，内容和A一致）

  \_size = 4

  \_capacity = 10

两个对象的 \_array 指向 不同的堆内存；

堆内存的内容完全相同（拷贝的是内容，而非地址）；

两个对象的堆内存互不干扰。

3\. 深拷贝的优势（避免崩溃 + 数据安全）

（1）无双重释放

析构时，s1 释放堆内存 A，s2 释放堆内存 B，各自释放自己的内存，无冲突，程序正常退出。

（2）数据互不干扰

修改一个对象的堆内存，不会影响另一个对象：

s1.Push(5); // 堆内存A变成 \[1,2,3,4,5,...]

s2.Push(6); // 堆内存B变成 \[1,2,3,4,6,...]

// s1 和 s2 的数据各自独立，无污染



***总结：什么时候必须用深拷贝？***

只要类中包含「动态分配的资源」（比如：

堆内存指针（malloc/new 分配）；

文件句柄、网络套接字等），就必须用深拷贝 —— 否则会导致：

内存泄漏；

程序崩溃（双重释放）；

数据污染（共享资源被意外修改）。

而你的 Stack 类正因为有 \_array 指向堆内存，所以必须显式定义深拷贝的拷贝构造和赋值重载，才能正常使用。

简单记：值类型随便浅拷贝，指针 / 动态资源必须深拷贝。



###### ***ps：***

遇到「两个已存在对象赋值」的场景，还会触发浅拷贝崩溃:

//Stack s1;

//s1.Push(1, 2, 3, 4);

//Stack s2; // 先构造s2

//s2 = s1; // 调用默认赋值运算符重载（浅*拷贝*），再次双重释放崩溃



对比维度	                    浅拷贝                                    	                                      深拷贝

核心操作	          复制成员变量数值（地址 / 值）	                        复制数值 + 堆内存分配 + 堆内容拷贝

时间开销	          极低（栈上操作，无系统调用）	                         较高（系统调用 + 数据拷贝，随数据量增长）

空间开销	           无额外空间（共享堆内存）	                                  额外空间（新分配堆内存，与原对象一致）

操作复杂度	  简单（编译器自动生成，无需手动实现）	  复杂（需手动处理堆分配、拷贝、异常）

典型耗时（参考）	几纳秒（ns）	                                          几十纳秒～几毫秒（ms）（取决于堆大小）



拷贝快但有适用限制，深拷贝慢但能保证正确性；先选对的，再选快的。

