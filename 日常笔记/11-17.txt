这是测试内容
缺省：                                                                                                                  缺省参数的核心是【编译期确定默认值、调用时左到右匹配】
1. 半缺省参数必须从右往左依次来给出，不能间隔着给                                       编译器从左到右匹配，中间参数有默认值而右侧没有，编译器无法确定参数对应关系。
2. 缺省参数不能在函数声明和定义中同时出现                                          声明是给调用者看，定义是给编译器看，混在一起，编译器不知道调用哪个
3. 缺省值必须是常量或者全局变量                                                       变量没有确定的值，调用时不知道会有什么值或者变量改变，局部变量有生命周期
4. C语言不支持（编译器不支持）                                                     


函数重载：？
是函数的一种特殊情况，C++允许在同一作用域中声明几个功能类似的同名函数，这些同名函数的形参列表(参数个数 或 类型 或 类型顺序)不同，常用来处理实现功能类似数据类型不同的问题。


引用：（给人起外号一样）
不是新定义一个变量，而是给已存在变量取了一个别名，编译器不会为引用变量开辟内存空间，它和它引用的变量共用同一块内存空间。

a. 引用在定义时必须初始化                                          给别人起外号，要找到那个人在起外号

b. 一个变量可以有多个引用                                          一个人可以有个外号

c. 引用一旦引用一个实体，再不能引用其他实体            你给人起了一个外号，你就会这么叫他，不怎么改这个外号给他

int& Add(int a, int b)
{
	int c = a + b;
	return c;
}                                                                                                 -----———— ————》》》 正常理解一开始是3，通过调用函数，但是生命周期结束，空间释放，引用的是                  
int main()
{                                                                                                                             被释放的空间，又因为3，4压栈进来应改是7 ，但是因为不同的编译器，打印的可能不是7，是
	int& ret = Add(1, 2);
	Add(3, 4);                                                                                                    空间地址，引用释放的空间时，悬空引用访问了无效内存，在某些编译器（如 VS2022）中，你                 
	cout <<  "Add(1, 2) is :" << ret << endl;                                                   的代码可能打印 3；在 GCC 中可能打印 7；在开启优化后可能打印随机数 —— 这都是未定义
	return 0;                                                                                                           行为的表现。
}

值和引用的作为返回值类型的性能比较
以值作为参数或者返回值类型，在传参和返回期间，函数不会直接传递实参或者将变量本身直接返回，而是传递实参或者返回变量的一份临时的拷贝，因此用值作为参数或者返回值类型，效率是非常低下的，尤其是当参数或者返回值类型非常大时，效率就更低。在底层实现上实际是有空间的，因为引用是按照指针方式来实现的

5. 在sizeof中含义不同：引用结果为引用类型的大小，但指针始终是地址空间所占字节个数(32位平台下占4个字节)

6. 引用自加即引用的实体增加1，指针自加即指针向后偏移一个类型的大小

7. 有多级指针，但是没有多级引用

inline：内联函数    无调用开销 + 类型安全 + 支持调试
消除函数调用开销，频繁调用的短小函数，向编译器发送建议，减少调用函数创建栈帧开销，有的编译器不允许，函数体短小（1-5 行代码，无复杂逻辑），有时编译器拒绝，
拒绝原因：
1. 复杂函数（含循环、switch、递归、大量局部变量，频繁调用的函数）；
2. 少被调用的函数（如程序启动时只调用一次的初始化函数，内联无意义）；
3. 需要取地址的函数（如函数指针、回调函数）；
4. 虚函数（运行时多态，编译时无法确定函数体）。
5. 避免过度内联                                                                                                        内联会导致代码体积增大（“代码膨胀”），影响cpu


auto:
自动类型推导,让编译器自动推导变量的类型

适用范围：
范围 for 循环遍历容器（最推荐）；
复杂类型（迭代器、lambda、STL 容器嵌套类型）；
临时变量，且类型明确（比如 auto res = func();，func 返回类型清晰）；
函数返回值类型复杂，且所有返回值类型一致（C++14+

不适用范围：
类型不明确，影响代码可读性（比如 auto x = some_func();，读者不知道 x 是什么类型）；
需要明确指定类型的场景
底层 const 敏感的场景（比如需要保留顶层 const，需显式声明 const auto）。

类的大小：
一个类的大小，实际就是该类中”成员变量”之和，不考虑成员函数。当然也要注意内存对齐，注意空类的大小，方便取值计算（不对齐也可以，修改对齐数就好了）。空类比较特殊，编译器给了空类一个字节来唯一标识这个类的对象。
 先看是否有 虚函数：有则加 vptr 大小（4/8 字节）；
再计算 成员变量 的总大小（遵循内存对齐）；
若无成员变量（或仅有成员函数 / 静态成员）：分配 1 字节占位符；
成员函数、静态成员不影响类实例大小。
class A1 {
public:
    void f1() {} // 成员函数                                                     4
private:
    int _a;     // 成员变量（int 占 4 字节）
};

class A2 {
public:
    void f2() {} // 仅有成员函数，无成员变量                            1
};

class A3 {}; // 空类（无成员变量，无成员函数）                   1

this指针：：？？？


C++程序在编译后的内存分布情况如下：

栈区（Stack）：

存放局部变量、函数参数、函数调用信息等。
数据的分配和回收都由系统自动管理。
具有自动释放内存的特性，随着函数的结束而自动销毁。


堆区（Heap）：

存放动态分配的内存，由程序员手动分配和释放。
用于存放程序运行中动态创建的对象或数组。
需要手动释放内存，避免内存泄漏.

全局/静态存储区（Data/BSS）：

存放全局变量、静态变量及静态常量。
在程序运行期间一直存在，直到程序结束才被释放。
初始化的全局/静态变量存放在Data区，未初始化的全局/静态变量存放在BSS区。
代码区（Text）：

存放程序的可执行代码，包括函数体和常量数据。
只读区域，不允许修改。
可以多个进程共享同一段代码区
