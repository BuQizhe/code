这是测试内容
缺省：                                                                                                                  缺省参数的核心是【编译期确定默认值、调用时左到右匹配】
1. 半缺省参数必须从右往左依次来给出，不能间隔着给                                       编译器从左到右匹配，中间参数有默认值而右侧没有，编译器无法确定参数对应关系。
2. 缺省参数不能在函数声明和定义中同时出现                                          声明是给调用者看，定义是给编译器看，混在一起，编译器不知道调用哪个
3. 缺省值必须是常量或者全局变量                                                       变量没有确定的值，调用时不知道会有什么值或者变量改变，局部变量有生命周期
4. C语言不支持（编译器不支持）                                                     


函数重载：？
是函数的一种特殊情况，C++允许在同一作用域中声明几个功能类似的同名函数，这些同名函数的形参列表(参数个数 或 类型 或 类型顺序)不同，常用来处理实现功能类似数据类型不同的问题。


引用：（给人起外号一样）
不是新定义一个变量，而是给已存在变量取了一个别名，编译器不会为引用变量开辟内存空间，它和它引用的变量共用同一块内存空间。

a. 引用在定义时必须初始化                                          给别人起外号，要找到那个人在起外号

b. 一个变量可以有多个引用                                          一个人可以有个外号

c. 引用一旦引用一个实体，再不能引用其他实体            你给人起了一个外号，你就会这么叫他，不怎么改这个外号给他

int& Add(int a, int b)
{
	int c = a + b;
	return c;
}                                                                                                 -----———— ————》》》 正常理解一开始是3，通过调用函数，但是生命周期结束，空间释放，引用的是                  
int main()
{                                                                                                                             被释放的空间，又因为3，4压栈进来应改是7 ，但是因为不同的编译器，打印的可能不是7，是
	int& ret = Add(1, 2);
	Add(3, 4);                                                                                                    空间地址，引用释放的空间时，悬空引用访问了无效内存，在某些编译器（如 VS2022）中，你                 
	cout <<  "Add(1, 2) is :" << ret << endl;                                                   的代码可能打印 3；在 GCC 中可能打印 7；在开启优化后可能打印随机数 —— 这都是未定义
	return 0;                                                                                                           行为的表现。
}

值和引用的作为返回值类型的性能比较
以值作为参数或者返回值类型，在传参和返回期间，函数不会直接传递实参或者将变量本身直接返回，而是传递实参或者返回变量的一份临时的拷贝，因此用值作为参数或者返回值类型，效率是非常低下的，尤其是当参数或者返回值类型非常大时，效率就更低。在底层实现上实际是有空间的，因为引用是按照指针方式来实现的

5. 在sizeof中含义不同：引用结果为引用类型的大小，但指针始终是地址空间所占字节个数(32位平台下占4个字节)

6. 引用自加即引用的实体增加1，指针自加即指针向后偏移一个类型的大小

7. 有多级指针，但是没有多级引用