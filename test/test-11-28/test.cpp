//class Date
//{
//public:
//	Date(int year = 1900, int month = 1, int day = 1)
//	{
//		_year = year;
//		_month = month;
//		_day = day;
//	}
//	Date(const Date& d) noexcept // 正确写法：参数应为const引用，并加noexcept
//	{
//		_year = d._year;
//		_month = d._month;
//		_day = d._day;
//	}
//private:
//	int _year;
//	int _month;
//	int _day;
//};
//
//int main()
//{
//	Date d1;
//	Date d2(d1);
//	return 0;
//}


// 这里会发现下面的程序会崩溃掉？这里就需要深拷贝去解决。
//#include <cstdlib>
//typedef int DataType;
//class Stack
//{
//public:
//	Stack(size_t capacity = 10)
//	{
//		_array = (DataType*)malloc(capacity * sizeof(DataType));
//		if (nullptr == _array)
//		{
//			perror("malloc申请空间失败");
//			return;
//		}
//		_size = 0;
//		_capacity = capacity;
//	}
//	void Push(const DataType& data)
//	{
//		// CheckCapacity();
//		_array[_size] = data;
//		_size++;
//	}
//	~Stack()
//	{
//		if (_array)
//		{
//			free(_array);
//			_array = nullptr;
//			_capacity = 0;
//			_size = 0;
//		}
//	}
//private:
//	DataType* _array;
//	size_t _size;
//	size_t _capacity;
//};
//int main()
//{
//	Stack s1;
//	s1.Push(1);
//	s1.Push(2);
//	s1.Push(3);
//	s1.Push(4);
//	Stack s2(s1);
//	return 0;
//}

//深拷贝和浅拷贝：
//
//以stack为例：
//
//Stack 类的关键成员：
//_array：指向堆内存的指针（动态分配，需手动释放）；
//_size / _capacity：普通值类型（栈上存储，直接复制无问题）。
//浅拷贝和深拷贝的差异，只针对「堆内存指针」，值类型的复制逻辑完全一致。
//
//1. 浅拷贝的定义
//编译器自动生成的拷贝构造 / 赋值重载，逻辑是：逐字节复制所有成员变量的「数值」―― 对于指针 _array，复制的是「堆内存的地址」，而非「地址指向的堆内存内容」。
//2. 浅拷贝的现象（原程序崩溃的核心）
//用 Stack s2(s1); 触发浅拷贝后，内存布局如下：
//s1 :
//_array → 堆内存[1, 2, 3, 4, ? , ? , ...]（容量10）
//_size = 4
//_capacity = 10
//
//s2 :
//	_array → 同一个堆内存[1, 2, 3, 4, ? , ? , ...]（和s1共享）
//	_size = 4
//	_capacity = 10
//
//	两个对象的 _array 指向 同一块堆内存；
//	堆内存的内容没有被复制，只是地址被共享。
//
//	3. 浅拷贝的后果（原程序崩溃 + 数据污染）
//	（1）直接崩溃：双重释放
//	程序退出时，s1 和 s2 会自动调用析构函数：
//	先析构 s2：free(s2._array) → 释放共享的堆内存；
//	再析构 s1：free(s1._array) → 再次释放同一块堆内存；
//	C++ 中「重复释放堆内存」是未定义行为，直接触发程序崩溃（内存错误）。
//	（2）隐藏问题：数据污染
//	即使不崩溃，修改一个对象的堆内存，会影响另一个对象：
//
//	s1.Push(5); // s1 往共享堆内存添加 5，此时堆内存内容为 [1,2,3,4,5,...]
//// s2 的 _size 还是 4，但 s2._array 指向的堆内存已被 s1 修改
//// 后续 s2.Push(6) 会覆盖 s1 的 5，造成数据混乱
//
//深拷贝的定义
//程序员显式定义拷贝构造 / 赋值重载，逻辑是：
//对于「值类型成员（_size / _capacity）」：直接复制数值；
//对于「堆内存指针（_array）」：
//为新对象分配 独立的堆内存（容量和原对象一致）；
//将原对象堆内存中的「内容」复制到新内存中；
//新对象的 _array 指向新分配的堆内存，而非原对象的地址。
//2. 深拷贝的现象（解决崩溃的核心）
//用显式深拷贝的拷贝构造函数创建 s2 后，内存布局如下：
//s1 :
//_array → 堆内存A[1, 2, 3, 4, ? , ? , ...]（独立堆内存）
//_size = 4
//_capacity = 10
//
//s2 :
//	_array → 堆内存B[1, 2, 3, 4, ? , ? , ...]（新分配的独立堆内存，内容和A一致）
//	_size = 4
//	_capacity = 10
//	两个对象的 _array 指向 不同的堆内存；
//	堆内存的内容完全相同（拷贝的是内容，而非地址）；
//	两个对象的堆内存互不干扰。
//	3. 深拷贝的优势（避免崩溃 + 数据安全）
//	（1）无双重释放
//	析构时，s1 释放堆内存 A，s2 释放堆内存 B，各自释放自己的内存，无冲突，程序正常退出。
//	（2）数据互不干扰
//	修改一个对象的堆内存，不会影响另一个对象：
//	s1.Push(5); // 堆内存A变成 [1,2,3,4,5,...]
//s2.Push(6); // 堆内存B变成 [1,2,3,4,6,...]
//// s1 和 s2 的数据各自独立，无污染
//
//总结：什么时候必须用深拷贝？
//只要类中包含「动态分配的资源」（比如：
//堆内存指针（malloc / new 分配）；
//文件句柄、网络套接字等），就必须用深拷贝 ―― 否则会导致：
//内存泄漏；
//程序崩溃（双重释放）；
//数据污染（共享资源被意外修改）。
//而你的 Stack 类正因为有 _array 指向堆内存，所以必须显式定义深拷贝的拷贝构造和赋值重载，才能正常使用。
//简单记：值类型随便浅拷贝，指针 / 动态资源必须深拷贝。

//遇到「两个已存在对象赋值」的场景，还会触发浅拷贝崩溃:
//Stack s1;
//s1.Push(1, 2, 3, 4);
//Stack s2; // 先构造s2
//s2 = s1; // 调用默认赋值运算符重载（浅拷贝），再次双重释放崩溃